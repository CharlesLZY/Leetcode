##### 分类整理

### 树 (递归是树的常见解法)
JZ7 中序+前/后序还原二叉树 (递归,通过前/后序确定root,中序确定左右子树vin.index(root))
LC889 前序+后序还原二叉树 (假设pre[1]是左支，通过后序来确定左支的长度post.index(left))
JZ8 二叉树的中序遍历的下一个节点 (画图分类讨论,有右支:右支最左;无右支:第一个是左子节点的父亲)
JZ26 判断一棵树是不是另一棵树的子树 (hasSubtree调用isSame，对自己的左右子树递归调用hasSubtree，isSame对双方的左右子树递归调用isSame)
JZ27/LC226 镜像反转二叉树 (每次递归交换左右子树，然后对子树递归)
JZ28/LC101 判断二叉树是否对称 (比较要两个树比, isSymmetric(p1.left, p2.right) and isSymmetric(p1.right, p2.left))
JZ32 层序遍历二叉树 (BFS Queue就完了)
JZ78 按行打印二叉树 (bfs, 把depth也放到queue state里面)
JZ33 检查数组是不是BST后序遍历 (把中序遍历看成是push的顺序，判断后序遍历是不是一个合法的pop顺序 JZ31) （找到第一个不大于root的，剩下的检查是不是都是小于root，然后对左右子树递归）
JZ34/LC112 二叉树中和为某一值的全部从根到叶的路径 (DFS)
JZ82/LC113 二叉树中是否存在和为某一值的从根到叶的路径 (DFS)
JZ84/LC437 二叉树中和为某一值的路径,不要求从根出发,也不要求叶节点结束，但是得从上到下 (DFS, 对每个节点都findpath一遍，res达到了target也继续找)
JZ36/LC426 BST转化成排序双向链表 (中序遍历，维护一个全局变量prev，记录当前节点的上一个是谁)
LC114 按照先序遍历的顺序把二叉树弄成链表 (递归,basecase是叶节点,leftTail = straighten(node.left) rightTail = straighten(node.right) leftTail.right = node.right node.right = node.left node.left = None 根据子树是否为空的情况返回最后一个节点node/leftTail/rightTail) (迭代(每次插一个左节点) 如果存在左子树，在左子树的最右节点，leftmost = node.right node.right = node.left node.left = None) 
JZ54 BST第k的节点 (中序遍历，维护一个全局变量n记录现在是第几个元素，每次递归完回来，判断一下是否已经找到了)
JZ37/LC297 序列化二叉树 (DFS或BFS 解码和编码保持一样的操作，DFS用递归，BFS用queue)
LC449 序列化BST (存一个先序遍历就够了,通过中序和先序还原)
LC428 序列化N叉树 (如果要按照leetcode的格式弄, 有点难, 最简单的方法就是多弄几个括号, 然后DFS递归。注意数字之间必须要有分隔符, 否则没法区分节点)
JZ55 二叉树的深度 (递归就完了)
JZ68/LC235 BST最近公共祖先 (三种情况left mid left，占两种就找到了。 利用BST特性，可以更简单，如果当前节点值为p或者q，就找到了，如果p,q不在同侧也找到了)
JZ86/LC236 二叉树最近公共祖先 (三种情况left mid left，占两种就找到了)
JZ77 z字形打印二叉树 (bfs, 把depth也放到queue state里面, 每层分开存, 遍历完之后, 偶数层reverse一下)
JZ79/LC110 判断是不是平衡二叉树 (子问题是求二叉树的深度，abs(depth(left)-depth(right)) <= 1, 最优解是在求深度的时候同时判断是否平衡)
LC96 给定节点有多少种BST (DP 中序遍历固定为排序后的数组,选定root,子结构是左右子树有多少种摆法，乘起来)
LC98 验证是不是BST (中序遍历完看看是不是sorted的, 或者递归检查, 每次传low和high)
LC108 排序数组转化成平衡BST (递归,每次取中点做根,左右平均分做子树)
LC1382 把BST转化成平衡BST (先中序遍历，转化成排序数组生成平衡BST, 生成平衡树,递归生成,每次找数组的mid,用一半的数去建树)
LC111 二叉树最小深度 (要单独叶节点或者只有一个子树的节点，否则空支都是0)
LC124 二叉树最大路径(可以从任何节点到任何节点,不需要经过root) (leftPath = max(0, halfPath(node.left) halfPath return max(leftPath,rightPath)+node.val MAX一定是leftHalf+node.val+rightHalf))
LC543 二叉树的直径 (最大直径一定是 leftPath + rightPath，但是maxHalfPath(node)返回的是max(leftPath, rightPath) + 1)
LC208 前缀树 (TrieNode 要维护自己是否是一个单词的结尾, 同时自己有26个children(对应26个字符))
LC538 BST的每个节点的值都加上比他小的所有节点值的和 (维护一个全局变量记录目前累加值,然后从右往左中序遍历)
LC617 合并二叉树,直接节点相加 (merge(r1, r2), 如果有一个是None，直接返回另外一个,递归到此结束, 其他情况再r1.left = merge(r1.left, r2.left) 最后返回r1)
LC94/LC144/LC145 如何用stack实现是难点，postorder：额外存一个bool，第一次pop出来，再放回去，第二次pop再访问。
inorder：维护一个nextToVisit, 如果nextToVisit还有左支，就一直append进stack, cur=stack.pop(), 如果cur有右支，把右支append进stack,更新nextToVisit
LC987 根据col,row,val来遍历树 (最直观的方法对所有节点排序，按照col,row,val的顺序排，可以优化成桶排序)
LC315 右边比自己小的数字的个数 (建一棵BST, ans = [0]*len(nums), 每个节点存值以外还存对应的index, 每次往一个节点左边插, 就ans[i]+=1
LC450 删除BST中的结点 (找当前节点的predecessor和successor(最左右儿子和最右左儿子), 递归调用deleteNode,return删除完了指定节点的root, 找到了key,就把当前节点修改成pred或者succ的val, 然后去删pred和succ)
LC285 BST中下一个节点 (维护一个success, 用while root, 如果root.val<=p.val, 就向右支走, 如果root.val>p.val,就更新successor,然后往左支走)
LC510 带父节点指针的BST中的下一个节点 (如果有右支就找最左右儿子, 如果没右支就找第一个自己在左支的父节点)

### 数组
JZ3/LC287/LC442 数组中重复的数字 (Negative Mark index, 因为数字范围在1到n之间)
LC448 数组中没出现的数 (Negative Mark index, 注意别重复mark)
JZ11/LC153 旋转数组最小数字 (key point: if rotateArray[left] < rotateArray[right]: return left，二分查找，因为可能有重复数字缩小范围的时候要注意处理相同的情况)
LC154 旋转数组最小数字
LC33 搜索旋转数组 (找pivot的位置(注意分类讨论), 会出现nums[lp]==nums[rp]只有在最开始的时候（或者最后只剩同一个数字）,头尾相同，根据二分的时候比较的对象选择是pop掉末尾的还是开头的，主义在找pivot的时候，如果遇到lp到rp之前是排好序的，直接返回lp)
LC81 搜索旋转数组 (找到pivot之后，如果pivot是第一个数，要把数组末尾和pivot相等的数字给pop光)
JZ39/LC169 数组中出现超过一半的数 (candidate和vote 一换一策略，最后剩下的就是过半的)
JZ42/LC53 最大子序和 (cur = max(n, cur+n) ans = max(cur, ans))
LC152 最大乘积子序 (记录curMIN等待他有机会闲鱼翻身, curMAX = max(nums[i], nums[i]*tmp, nums[i]*curMIN), curMIN = min(nums[i], nums[i]*tmp, nums[i]*curMIN), 但要注意curMAX和curMIN得同时更新, 或者用DP填表存一下就没这个问题)
JZ48/LC3 最长不重复子串 (hashtable 记录上一次出现的位置, 更新lp或者维护一个lp(标记sliding window的left end), 遇到重复的就从lp开始删hashTable)
JZ57 增序数组中的two sum (双指针，大了rp-1，小了lp+1)
JZ59/LC239 滑动窗口中的最大值 (monotonic stack(存index), 维护一个递减的stack，stack[0]就是当前窗口的最大值的index，但同时要检查stack[0]是否小于lp)
JZ66/LC238 乘积数组，不包括自己的其他元素之积 (不能用除法，DP维护left和right, ans[i] = left[i] * right[i], 也可以inplace修改原数组为left或right, 然后再倒着乘回来)
JZ85 最长的最大和子序 (额外维护lp,rp和cur_lp,cur_rp，更新MAX的时候更新lp和rp)
LC1 two sum (用complement当hashindex)
LC4 两个递增数组的中位数 (二分法(注意rp要从m开始，因为partition的范围可以取len(nums1))在短的那个数组里查找partition, 长的数组的位置可以由短的那个对应算出来, partition左边的应该都小于右边的, 维护leftMAX_1, rightMIN_1, leftMAX_2, rightMIN_2,用inf避免corner case, partition一定存在可以用while True)
LC15 3sum (先排序, 遍历数组，选定一个数，用左右双指针不断向中间收缩，在剩下的数组找2sum=complement)
LC55 Jump Game 在数组里面能否跳转到最后一个 (维护一个canReach)
LC45 Jump Game 最少的步数跳到结尾 (维护currentJumpEnd和canReach，if i == currentJumpEnd: jumps += 1 currentJumpEnd = canReach)
LC1306 Jump Game 只能向左或向右跳规定步数, 能不能跳到0 (BFS + negative mark visited)
LC56 合并区间 (先排序)
LC121 只能买卖一次股票，最大收益 (维护一个目前最低价curmin, ans = max(curmin - cur, max))
LC122 随便买卖多少次 (greedy，只要明天涨,今天就买了,ans += prices[i] - prices[i-1])
LC128 未排序数组最长连续序列 (用set(), 支持O(1)查找, 长到不能长再算长度，如果num+1不在表里就用while检查num-1)
LC252 会议安排是否有重叠 (sort一下就完了)
LC253 要安排几间会议室 (维护一个end time的min heap, 如果新会议的start time比min heap的top晚,就pop, 否则就push end time) (或者把start 和 end看成独立的，分别sort,有start就会议室数量+1,然后和end比,每遇到一个比他小的end, 就会议室数量-1)
LC283 把0移到末尾,保持其他数相对位置不动 (代码类似快排，遇到非0就和左边第一个0交换(或自己)交换)
JZ81 确保奇数在偶数前面 (代码类似快排，奇数每次出现和左边第一个偶数(或自己)交换)
JZ21 确保奇数在偶数前面保持相对位置不变 (类似快排，每次遇到奇数, 放到左边最后一个奇数后面，并把这之间的所有偶数向右平移一位)
LC406 根据高度和rank重建数组 (people.sort(key = lambda x: (-x[0], x[1])) 按身高降序 rank升序排好, 从高到底按照rank直接插ans.insert(rank, p))
LC325 最长连续子序和为指定值 (核心思想sum(arr[i:j]) = sum(arr[:j]) - sum(arr[:i]), hashtable 存累计和和出现次数(初始化要把0：1放进去)) 
LC560 有多少连续子序和为指定值 (核心思想sum(arr[i:j]) = sum(arr[:j]) - sum(arr[:i]), hashtable 存累计和和出现次数(初始化要把0：1放进去), 遍历一遍，更新累计和, 每次检查target - curSum是不是在hashTable里面)
LC862 最短的连续子列和大于k (prefix sum + ascending stack)
### LC621 CPU Task Scheduler 相同任务之间得间隔n,可以用idle填槽 (用Counter统计每个任务的freq, 维护一个max heap(存每个任务的待完成次数)(通过从heap中取出和放回的操作模拟cpu执行任务，一个任务在一个cooldown period里面被取出了，相当于被占用了), 
每一个slot长度为n+1，从heap里面pop元素填slot,要么填满或者heap空了,然后一一检查slot里面的元素,给待完成次数-1，如果不为0就放回heap，如果heap还有东西，说明前面的slot不是最后一个slot,直接ans += n+1)
LC398 给定一个目标值随机从数组中返回一个index (要么hash table 存一下相同数的index, 要么reservoir sampling)
LC259 有多少对3Sum smaller (锁定一个pivot然后转化成求2sum smaller有几对，用双指针不断缩小范围，每次找到一对,因为是排过序的，剩下的肯定也是小于的)
JZ53 升序数组中数字的出现的次数 (二分搜索找k和k+1, 搜索return min(lp,rp)， 只要mid >= target就rp = mid - 1)
LC217/219 数组中是否包含重复的数字 (hash table存一下之前的， sliding window 维护k长度)
LC220 数组中是否包含两个数的差值在t之内 (hash table用num // t当idx, 这样相当于标记了[num, num + t)开区间，左邻区间和num+t仍要检查, 同时要注意t可能等于0)
LC414 找第三大的数字 (用set，动态维护当前最大的3个数，或者O(3n)每次删一个最大数)
LC1002 判断数组中的所有字符串的公共字符有哪些 (用collections.Counter, 选一个作为初始参考对象, 不断缩小counter)
LC2080 查找指定范围内某数字出现次数 (用searchFirstGE去找left, 用searchFirstLE去找right, 这题属于根据需求设计数据结构, 要最快可以用hash存前缀出现次数)
LC986 区间求交集(两个指针分别遍历两个数组, lp = max(A[i][0], B[j][0]) rp = min(A[i][1], B[j][1]), endpoint小的数组的指针前进)

### 二维数组
JZ4 行列递增二维数组的查找 (start from (1,n), eliminate one col/row each time)
JZ29/LC54 顺时针打印矩阵 (打印bottom和left的时候加个判断，是否和up和right重叠了, 循环用的while len(ans)< h*w )
JZ47 二维数组只能向右或下走，求最大路径 (DP, 先把第一排和第一列填了)
LC1314 矩阵卷积和 (prefix sum, DP[i][j]是右下角在(i,j)的矩形的和, ans[i][j] = DP[i+k][j+k] - DP[i][j-k-1] - DP[i-k-1][j] + DP[i-k-1][j-k-1])
LC200 岛屿数量 (遍历二维数组, 维护visited list, 每遇到一个1,就开始DFS(用stack实现))
LC329 矩阵中最长递增路径 (DFS + memoization, 因为是递增路径, 所以是DAG没环的)

### 链表 (链表的题一定要先判断有没有环, 快慢指针是最常用的trick,可以用来找环，找中点，找倒数第k个的元素。多声明一些临时变量,dummy head, 方便连来连去)
LC82 删除有重复的节点，本体和分身都不留(维护prev和cur,在有重复值的情况,只更新prev.next,跳过重复的值)
JZ6 逆序打印链表 (recursive to tail)
LC234 判断链表是否是回文的 (递归,需要维护一个全局的cur, 递归会一直到链表的tail,然后再一层一层回来, cur则正向往下走, 也可以用快慢指针，把后一半reverse，然后一一比对，这样可以实现O(1))
JZ18 删除链表节点 (遍历就完了)
JZ22/LC19 链表倒数第k个结点 (快指针先走k步)
JZ23/LC141 链表中环的入口 (快慢指针，标准写法fast和slow初始化都是head)
JZ24/LC92 反转链表 (dummy head, 如果是指定区间反转要在整个链表前加一个dummy head)
JZ25/LC21 合并两个排序链表 (每次比较第一个)
LC23 合并k个排序链表 (k个排好队，每次挑个最小的)
JZ35/LC138 随机链表的复制 (先不管random link复制一遍，把新旧两个组装在一起old-new-old-new ..., old->next = new, 这样可以用old.random去定位new.random, 连完random link，然后再把新旧链表拆开)
JZ52/LC160 两个链表的相交处 (无环的情况下,从两条链表分别开始走，到头了就从另一个链表头重新开始，最后相遇在交点。有环的话，快慢指针从一条链表开始走，把环入口找到)
JZ62 围成一圈报数，求最后剩下的人 (用一个环形链表模拟)
JZ76 删除重复节点 (维护一个prev)
LC2 用链表模拟两个数相加 (维护一个addition carry flag) 类似的LC43(要补0对齐)
LC25 k个一组倒序链表 (递归返回newhead或者遍历，遍历解法要耐心，多画图给理清楚，子问题就是倒序链表)
LC146 LRU Cache (hashmap(存node) + double linked list, head和tail node负责O(1)插入或者删除, hashmap负责O(1)查找, 要额外实现moveToHead, addToHead, delete)
LC460 LFU Cache (hashmap(存node)+freqTable(存每个freq的LRU cache) + 多个double linked lists(freq lists)) Hash Table: {key : DLinkedNode} freq Table: {freq: DlinkedList})
LC148 排序链表 (merge sort, 用快慢指针找中点, 找到之后要把前后两段**剪开,把next设成None**再去递归,而且有一个细节,取中点一定要往前取(不然会死循环在长度为2的情况),所以要维护一个prev)
LC287 数组中重复的数字 (negative mark, 或者用value当index, 链表找环入口)
LC61 旋转链表 (dummy node要加，先获取链表长度, 然后k = k % length 如果k==0 直接返回head，然后用快慢指针，找tail newHead, newTail)
LC24 交换奇偶节点 (快慢指针, 代码框架和找环的类似)
LC143 重新排序 (1.找中点 2.倒序后半段 3.合并2段)

### Graph
LC207 前置课程是否可行 (建图,所有课程都要维护邻接数组,DFS判断图里面有没有环, 维护一个visited list和一个look up list, ***look up list需要backtrack***, 
通过查看邻居是否被look up, 判断是否有环, 每个节点在被访问到的时候更新visited和look up, 在遍历图的时候也要跳过visited的节点，DFS的过程是在找环)
LC210 上课顺序 (用字典建图，拓扑排序, queue维护当前in-degree=0的node, 然后给它的succ的in-degree减1,最后检查是不是所有节点的in-degree都减成0了)
LC399 给定已知的除法，推出其他除法 (用字典建图,字典存边长(nested dict,因为要存edge weight), 一个除法式子可以画两条边, 看看能不能从起点出发找到终点)
399和207的区别在于，207是找环, 399是给定起点找终点，399就是普通的图遍历
LC127 最短单词接龙 (先用一个字典记录xxx*xxx这种pattern对应的单词有哪些(相当于是把每个state的succ的映射都给建好了)，然后BFS(保证最优性),记得维护visited list，在把节点放进queue的时候就可以标记visited了，这样可以剪枝)
LC126 找到所有的最短单词接龙 (这题和LC127不一样,只能在一个word从queue中pop出来之后再标记为visited)
LC133 图拷贝 (要维护visited={}, visited[node] = copy, 写一个clone(node) return copy)
LC529 扫雷 (用queue实现, 一次处理一个pos, 看这个pos周围的地雷有几个, 记录当前节点有几个地雷, 如果一个地雷都没有就要把他8个方向的其他pos都加到queue里面继续explore)

### 并查集
LC323
LC547
LC684

### Stack/Queue
LC300 最长递增子序 (如果比stack里面的大就append, 否则找stack里面第一个大于**等于**的替换，最后stack就是最长子串)
JZ9/LC232 两个stack实现queue (每次需要pop,如果stack2是空的，就把stack1现有的全部pop放进stack2(正好是最先进stack1的在stack2最上面)，然后正常pop stack2)
LC225 用queue实现stack (只需要维护一个queue, 每次push完, 把之前的一个一个pop+append, 最后新push进来的在queue最前面)
JZ30 最小栈 (用两个stack，另外一个存实时的min, 不比栈顶的min小, 就不更新实时min,还是push之前栈顶的min)
JZ31 给定stack压入顺序，判断pop顺序是否合法 (模拟stack的push,当push的时候遇到和poplist当前位置一样的值，开始尝试pop直到不能pop，剩下的poplist依次检查)
JZ75 字符流中第一个不重复的字符 (除了hash table，还要维护一个queue，每次遇到新字符push进去，然后每次查询只出现一次的字符都要清理一下queue)
LC20 合法括号 (stack就完了, 左括号就push,遇到右括号,检查能不能和pop出来的匹配)
LC32 最长合法括号 (只用stack[0]来表示上一个非法')',所以一开始初始化成[-1]，stack中第一位不动，后面存'('位置，只有当stack中没有'(',即len(stack)==1,才更新上一个非法')'
每次遇到')'如果len(stack)!=1，意味着还有'('，就pop掉，然后curLength = i - stack[-1],更新max length)
LC394 解码字符串 k[xxx] (首先parse数字(isdigit和isalpha)的时候,可能不止一位,要parse到底遇到'['为止, 然后stack一直push,直到遇到]，开始pop，找到左括号之后，找k，括号内的内容存在temp里面，最后再把temp*k push回stack，最后返回''.join(stack))
如果LC394用递归写，要写一个helper func，找当前左括号的对应右括号的相对位置，方便递归, 但要注意相对位置得加上之前***左括号的位置***，递归之后也要跳过括号内的内容
### Monotonic Stack
while stack and stack[-1] ... :
	stack.pop()
stack.append()
JZ59/LC239 滑动窗口中的最大值 (monotonic stack, 维护一个递减的stack，stack[0]就是当前窗口的最大值的index，但同时要检查stack[0]是否小于lp)
LC42 接雨水 (descending stack， 每次遇到更高的，把前面的踢掉，然后更新在踢掉的那个的高度上能蓄的水)
LC84 直方图中最大的矩形 (ascending stack, stack[0]初始化成-1, 用来最后计算宽度，遇到比前一个低的就pop，每次pop都要算一下当前的矩阵，用pop掉的前一个来计算宽度，全部push进stack之后，剩下的stack再挨个pop，算面积)
这两道题是每次pop的时候更新ans
LC739 给一个数组每个位置要过多少天才能遇到更大的 (维护一个descending stack,存index,遇到更大的就pop前面的更新天数,stack存index)
LC581 最短无序子序 (正着跑一遍 维护ascending stack, 遇到递减的,它会一直pop stack里面的index,直到来到他应该在的位置, 记录最小的misplaced index, 类似的倒着来一遍，找到最大的misplaced index)
LC402 删掉k位之后最小的数字 (维护一个递增栈，把所有digit入栈之后，要把剩下的k用完，此时stack是升序，直接不要最后k个就完了，最后要处理leading 0)
LC224/227/772 中缀表达式计算器 (先去掉所有的空格, 维护numStack, operatorStack, 维护numStack和operatorStack
遇到一个新的operator, 如果优先级小于等于operatorStack之前的operator, 就把前面所有优先级高的operator处理掉, 每处理完一个operator, 
遇到负数开头,就先往numstack放一个0,再往operatorStack里面放一个-
写一个calOnce(), 每次处理一个operator,把结果push回numStack, 栈里面最多只会有一个'+'或'-'和一个'*'或'/')
LC71 简化路径 (维护一个stack, 遇到..就pop, 最后把stack剩下的组成一个合法路径)

### Greedy
LC322 硬币找零(greedy, 下界是amount除以最大面值, 然后从理论上最少的找零数量去做限制深度的DFS)
LC279 一个数最少可以拆成多少个平方数 (可以用greedy的方式限制深度, 从最小的深度开始dfs，因为深度最大n(n个1相加),这样可以减少平均时间复杂度)
LC122 随便买卖多少次 (greedy，只要明天涨,今天就买了,ans += prices[i] - prices[i-1])
LC630 最多可以在ddl前上几门课 (用maxheap代表目前选的课, 先按照ddl对课程排序, 能塞进课就先上, 塞不下了, 把目前上了的课耗时最长的给删掉)

### DP (recursion with memoization, if DP[i] != None: return DP[i] 通常用在递归有大量重复的情况)
JZ42/LC53 连续子数组的最大和 (DP[i] = max(DP[i-1]+array[i], array[i]) where DP[i] Maximum sum of sub-array ending at i)
LC70 斐波那契数列
JZ14 剪绳子 (DP[n] = max_i: i * max(n-i, DP[n-i]) 因为至少要剪2刀，i是第一段的长度，不能只用DP[n-i], 是因为DP是至少剪了一刀，不剪可能更长) 
JZ19/LC10 正则匹配 (维护s_i和p_j, 先看是不是_*, 如果是先跳过2个,看看能不能匹配上,再匹配当前，只有当p_j超出长度且s_i刚好匹配完，才返回true，s_i 跑完了返回False不能放在开头判断，因为有可能现在还处在.* )
LC44 通配符匹配 (维护s_i,p_j,match,star，优先处理匹配单个字符, 遇到*先记着, 然后pass继续往下匹配,匹配不到了,再回到之前遇到的*)
JZ46 数字对应26个字母 (类似于跳台阶, 如果num%100在10到25之间就可以用一个字母表示,即一次走2步DP_table[i+1] = DP_table[i] + DP_table[i-1],否则DP_table[i+1] = DP_table[i])
JZ49 丑数 (uglyNum = 2^p_2 * 3^p_3 * 5^p_5, DP[i] = min(DP[p_2]x2, DP[p_3]x3, DP[p_5]x5) 得到DP[i]之后还要继续更新p2 p3 p5跳过重复的丑数 )
JZ70 矩形覆盖 (类似爬楼梯)
JZ71 跳台阶拓展，一次可以跳n节 (f[n] = f[n-1] + f[n-2] + .. + f[1] + f[0], 数列求通项)
LC5 最长回文子串 (DP[i][j]：str[i:j]是否是回文; 或者每一个位置选做中心不断r++,开始向外扩散，要分类讨论baab和bab，checkPalindrome: return s == s[::-1])
LC647 一共有多少个回文子串 (中心扩散,注意分类讨论aba和abba)
LC62/63 机器人走到右下角的走法 (先初始化第一行和第一列，都是1，如果有障碍物就直接0，初始化的时候注意，有障碍的时候，第一列和第一行一个0之后都是0)
LC64 二维数组中最小的路径 (DP多加个min)
LC72 编辑距离 (If word1[i] == word2[j]: DP[i][j] = min(DP[i-1][j]+1, DP[i][j-1]+1, DP[i-1][j-1])  else: DP[i][j] = min(DP[i-1][j]+1, DP[i][j-1]+1, DP[i-1][j-1]+1))
LC161 One Edit Distance (用不到DP，分类讨论就行)
LC96 给定节点有多少种BST (中序遍历固定为排序后的数组,选定root,子结构是左右子树有多少种摆法，乘起来)
LC123 股票只能买卖两次 (做两次DP,正着走,对于每个时间点,找之前的最低价, 倒着走，更新rightMAX。最后求max(MAX, leftProfits[i] + rightProfits[i]) )
LC139 字符串可否拆分成字典里面的词 (DP[i]代表s[:i+1]是否可以拆成字典里的词, DP[i] = DP_table[j] and s[j:i] in wordDict )
LC198/213 劫匪抢劫得隔家抢 (DP就完了, 如果成环，就分两种情况讨论，抢不抢第一家[0:len(nums)-2], [1:len(nums)-1])
LC221 二维数组中的最大正方形 (if matrix[i][j] == 1: DP[i][j] = min(DP[i-1][j], DP[i-1][j-1], DP[i][j-1]) + 1, DP[i][j]右下角在(i,j)的正方形)
LC204 数小于n的素数有几个 (for p in range(2, int(sqrt(n)) + 1):, p的倍数全部不是素数，用primes = [False, False] + [True] * (n - 2)标记)
LC279 一个数最少可以拆成多少个平方数 (首先要把所有小于等于根号n的平方数列出来,DP[i] = min DP[i - s] + 1)
LC322 硬币找零 (DP[S] = min DP[S - c] + 1)
LC518 一共有多少种找零的方法 (for c in coins: for n in range(c, amount + 1): DP_Table[n] += DP_Table[n - c]), 每次只用一种硬币, 在所有可能的amount, 如果最后一枚币是c，之前有多少种可能)
LC337 劫匪在一棵二叉树里面抢 (recursion with memoization, 分两个DP_table,一个是rob[] 一个是notRob[], DFS(node, robParent), 或者每次DFS直接把rob和notRob的结果都返回了)
LC300 最长递增子序(不要求连续) (for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: DP[i] = max(DP[i], DP[j]+1))
LC325 最长连续子序和为指定值 (核心思想sum(arr[i:j]) = sum(arr[:j]) - sum(arr[:i]), hashtable 存累计和和出现次数(初始化要把0：1放进去)) 
LC1314 矩阵卷积和 (prefix sum, DP[i][j]是右下角在(i,j)的矩形的和, ans[i][j] = DP[i+k][j+k] - DP[i][j-k-1] - DP[i-k-1][j] + DP[i-k-1][j-k-1])
LC309 有冷却期的买卖股票 (sold[i] = hold[i−1] + price[i]  hold[i] = max(hold[i−1], ready[i−1] − price[i])  ready[i] = max(ready[i−1], sold[i−1]))
LC338 返回1到n每个数二进制有多少个1 (DP[x] = DP[x >> 1] +  x & 1)
LC416 数组中是否可以分成2个和相等的子集 (recursion with memoization DP = {(curIdx, curSum) : whether the remaining numbers in the array can achieve the target}  DP_table[(idx, res)] = DFS(idx+1, res+nums[idx]) or DFS(idx+1, res))
LC494 给一个数组只用+-, 有多少种可能组合出给定值 (recursion with memoization，DP_table = {} ### { (curIdx, curSum) : number of ways to achieve the target sum}  DP_table[(idx, res)] = DFS(idx+1, res+nums[idx]) + DFS(idx+1, res-nums[idx]))
LC85 二维数组中最大的矩形 (DP用来算这一格在当前这一行以它为终点的最大的宽度，每一列看成一个子问题,直方图中最大的矩形)
LC312 打气球 (DP[i][j] = max(DP[i][k-1]+DP[k+1][j]+nums[i-1]*nums[k]*nums[j+1]), 指定k最后打爆, recursion with memoization, 方便起见, 初始化nums = [1] + nums + [1])
LC1262 最大能被3整除的子集和 (数学方法可以分类讨论做，DP[i][j] means the maximum possible sum (%3==j) end at i)
LC97 交错(interleaving)字符串 (recursion with memorization, 记录DP[i][j]代表s1[:i]和s2[:j]是否能形成s3[:i+j])
2维的DP表都可以优化成一维的DP表, 只要是一行一行来的
LC87 Scramble String (recursion with memorization, DP table的stage用s1+s2)
LC120 三角形 (从上到下一层一层DP, 每一节点的最小走法依赖于上一层)
LC718 最长公有子串 (DP[i][j]是nums1[:i]和nums2[:j]的公共tail的长度)

### Backtrack
JZ12 矩阵中的路径
LC79 单词搜索 (因为可以上下左右走,要维护visited，可以inplace维护，但要记得backtrack)
JZ13 机器人的运动范围
JZ38 字符串的全排列 (用Counter, 判断下一个char用哪个)
LC46/LC47 全排列 (用Counter，也可以排序了之后，剪掉同位置相同元素的分支，如果元素都不相同，可以做到inplace，记录idx，每次都是swap)
LC22 生成全部指定数量的合法括号 (每次递归传n_lp和n_rp，n_lp >= n_rp才可以加rp)
LC39 数组中和为给定值的组合 (先排序再DFS，排序可以减少复杂度，不排序也可以)
LC78 数组的全部子集(每一个数可以塞进去，也可以跳过)
LC139 字符串可否拆分成字典里面的词 (如果用递归，要维护一个visited，因为s[:i]可以由多个组合可能,但之后的DFS进行一次就够了)
LC200 岛屿数量 (遍历二维数组, 维护visited list, 每遇到一个1,就开始DFS(用stack实现))
LC279 一个数最少可以拆成多少个平方数 (可以用greedy的方式限制深度, 从最小的深度开始dfs，因为深度最大n(n个1相加),这样可以减少平均时间复杂度)
LC322 硬币找零(greedy, 下界是amount除以最大面值, 然后从理论上最少的找零数量去做限制深度的DFS)
LC301 最少删除几个括号可以合法(全部可能性) (首先要写一个isValid(), 在DFS前要先统计非法的n_RP和n_LP,DFS(string, start, n_LP, n_RP), 如果可以先删RP(因为RP没删干净前，删LP是没意义的)
如果遇到连续的括号,删掉第一个,然后跳过剩下的) 
LC93 合法IP (写个valid()判断segment, dots寸dot的位置,每次确定一个valid segment就加一个dot的位置, 最后一个dot就是s的末尾)

### Two Pointer
JZ57 增序数组中的two sum (双指针，大了rp-1，小了lp+1)
JZ74 所有和为S的连续正整数数组 (lp和rp都从1开始, 如果小了就rp++, 大了就lp++)
LC11 能盛最多水的容器 (初始化lp，rp在左右两端，更新容积，然后哪边矮，哪边的指针往中间移)
LC42 接雨水 (维护一个leftmax和rightmax 初始化为0, 如果lp比rp小，且lp比leftmax小，更新当前这格配合leftmax能蓄的水，否则更新leftmax, lp++, 如果rp比lp小类似的)
LC75 排序法国国旗 (用while cur <= rp，cur遇到0和lp交换，lp++,cur++，cur遇到2和rp交换rp--，cur不动，换过来的是啥我们不知道, 留在原地继续处理换过来的数)
### LC41 数组中缺失的最小正数 (默认答案为len(nums)+1), 如果数值做index来标记, 遇到数值不在其对应的index上,就交换,这时候while的循环变量不要++,因为我们不知道换过来的是什么)
LC76 最短包含目标字符串的子串 (用Counter记录当前匹配情况,每次满足条件之后就开始尝试缩小window, for rp in range(len(s)) 每找到一个子串更新MIN, lp++, 但counter里面可能会有负数因为有冗余次数，所以需要额外维护一个n_toCheck，来记录当前是否不匹配)
LC438 全体同分异构字符 (用Counter，一个char次数变为0了，从Counter中删除, 双指针explore字符串)
76和438不太一样，一个是要包含一个是要完全一样，所以LC438要把不在pattern里面的字符也统计进counter
LC209 正数组里面最短的连续子序大于等于target (维护一个lp, 然后用for n in nums的结构)
LC392 判断是不是子序 (遍历母串, 如何当前字符相同子序指针前进)

### Sort/Search
LC57 插入新的interval (分4种情况讨论, newInterval的lp和rp在不在intervals里面, search要写成while lp<=rp, lp=mid+1, rp=mid-1, return lp(因为lp可以加到len(arr)))
LC34 在排序数组中找一个数第一个和最后一个 (写一个findFirstEqual, 通过最后判断lp<=rp来判断找到的上下界对不对)
LC69 开根号 (二分法, lp=2, rp=x//2, 比较mid*mid和x谁大)
JZ40 最小的K个数 (维护一个大小为k的最大堆) (quick select, 写完partition, 接下来可以用二分法, 但要注意lp=mid+1 rp=mid-1)
LC215 快速选择 (TC:O(n), 找pivot用for, 记得加random,和high交换一下，select可以用递归,也可以用二分)
LC347 k个最高频出现的数 (用Counter.values，然后quick select, 或者用Counter，然后维护一个大小为k的min heap, heap 里面存(count, val))
JZ41 数据流的实时中位数 (维护一个minHeap(右半部分)和一个maxHeap(左半部分)，控制两个heap的size差别不超过1, 
控制方法先看比maxheap顶小就先push，如果push完长度差大于1，就pop出来push进min heap)
JZ51 逆序对 (merge sort, 每次merge之前先用双指针同时遍历左半边和右半边 统计一下逆序对（left[i] > right[j], 那么left[i:]全部大于right[j],一次更新mid-i+1个逆序对)
LC493 超级逆序对 (每次merge之前先用双指针同时遍历左半边和右半边 统计一下超级逆序对, 一次更新mid-i+1个逆序对)
LC315 后面比自己小的数字 (merge sort, 首先维护一个ans[], 维护一个arr存数组中每个数的值和对应的初始index, 对着arr归并排序（用原始数组当aux,因为arr里面存了index所以可以快速查询）,
只有左半边会导致ans更新, 每次放一个左半边的, ans += i - p1, 要么是0,要么就是之前塞到左半边的右半边的数)
LC4 两个递增数组的中位数 (二分法(注意***rp要从m开始***，因为partition的范围可以取len(nums1), partition是对应中位数左边的位置,)在短的那个数组里查找partition, 长的数组的位置可以由短的那个对应算出来, 
partition左边的应该都小于右边的, 维护leftMAX_1, rightMIN_1, leftMAX_2, rightMIN_2,用inf避免corner case, partition一定存在可以用while True)
LC31 刚好比目前大的数 (找到最后一个不递增的数字(剩下的一定都是递减的)，找到最小的比它大的数字(如果有重复的，就选最后一个), 交换完了剩下的还是递减的，然后reverse一下就行了)
LC162 找一个局部极大值 (题目要求相邻的数不会相等, 如果mid > mid+1，那么一定能在nums[:mid]找一个, 如果mid < mid+1，那么一定能在[mid+1:]找一个)
LC1901 二维数组找极大值 (选mid行，找这一行的最大值，看上下那个比max大，那么这个数比mid这一行都大，那么那一半一定有个极值点，想象一下二元函数的曲面)
LC127 最短单词接龙 (先用一个字典记录xxx*xxx这种pattern对应的单词有哪些(相当于是把每个state的succ的映射都给建好了)，然后BFS(保证最优性),记得维护visited list，在把节点放进queue的时候就可以标记visited了，这样可以剪枝)
LC126 找到所有的最短单词接龙 (这题和LC127不一样,只能在一个word从queue中pop出来之后再标记为visited)
LC139 word break (要维护一个visited，因为s[:i]可以由多个组合可能,但之后的backtrack进行一次就够了)
LC140 word break II (要把所有可能都找到，就不能像LC139那样维护一个visited list)

### Fancy Skills
LC231 判断一个数是不是2的次方 (2的次方只有1个bit是1, 直接return n & n-1, 但要处理n=0的情况)
LC470 用rand7实现rand10(采样2次，return idx%10+1。 p = 40/ 49 and E(# loops) = 1 * p + 2 * (1-p) * p + 3 * (1-p)^2 * p + ...)
LC8 atoi (检查overflow的时候，只用检查是不是超过INT_MAX // 10或者result == INT_MAX // 10 and digit > INT_MAX % 10, 因为INT_MIN范围比INT_MAX大1)
JZ15 二进制中1的个数 (这题本身就是数1，不断的&1然后>>1就完了，只是负数要转换成补码 n&0xffffffff)
JZ16/LC50 快速幂 (首先要把指数转换为正数，然后根据指数这一位是不是1，更新ans，每次都要平方底数和位移指数)
JZ43 自然数中1出现的次数 (观察0-9,10-99 ... ，猜一个答案)
JZ45 给一个数组，用这些数组成的最小整数 (转成str, 用a+b > b+a 来排序) 
LC48 旋转图像 (先转置再镜像)
LC136 数组中只出现过一次的数 (用xor，最后剩下的就是)
LC268 数组中没出现的数(n个数范围0到n) (排序,set()完看看谁不在set里面,0到n求和减去数组求和,用xor, 0到n xor一遍,然后再xor数组的每个数)
LC461 两个数二进制有多少位不一样 (看看xor有多少个1)
LC29 不能用乘除模拟a//b (用减法模拟,每次减的东西一直<<，直到减不动还原成最初的被除数，while套while)
LC49 把同分异构体分组 (用hash table 存sorted(string),或者用tuple模拟Counter)
LC205 判断两个字符串是不是结构相同 (写一个parse, 把无论原本的字符是什么,全部转化成AAABBB这样。维护两个mapping_s_t和mapping_t_s，AAABBB和CCCDDD(mapping_s_t存A:C)对不上就return false)
LC127 单词接龙 (用一个字典记录xxx*xxx这种pattern对应的单词有哪些，然后BFS,记得维护visited list，在把节点放进queue的时候就可以标记visited了，这样可以剪枝)
LC69 开根号 (牛顿法，用taylor一阶近似求f(x) = x^2-n=0的解，迭代下去，如果用梯度下降的话，目标函数得改成g(x) = (x^2-n)^2)
LC89 构造Grey Code (镜像法:镜像n-1的情况, 然后一半补0, 一半补1)
LC166 分数转小数 (通过记录remainder来判断循环小数是否会出现)